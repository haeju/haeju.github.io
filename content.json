{"meta":{"title":"dev blog","subtitle":null,"description":null,"author":"haeju.park","url":"https://haeju.github.io","root":"/"},"pages":[],"posts":[{"title":"Electron에서의 파일처리","slug":"electron-file-rw","date":"2019-08-28T05:10:36.000Z","updated":"2019-08-28T05:41:39.549Z","comments":true,"path":"2019/08/28/electron-file-rw/","link":"","permalink":"https://haeju.github.io/2019/08/28/electron-file-rw/","excerpt":"","text":"ipc 통신 electron에서의 파일처리는 node.js에서 제공하는 fs(file system) 모듈로 이용가능 하다. 단, Renderer Process에서 사용하기 위해서는 아래와 같이 “nodeIntegration: true”로 설정되어야 한다. 바로 사용해도 무방하지만 fs(file system)은 가급적 MainProcess에서 처리하는걸로 하였으며 이에 ipc 통신을 통해 처리되도록 기능 추가. 이벤트 등록 Main Process에서 src/main/ipc/fs.js 작성하면 Wrapper모듈을 ipc 이벤트로 등록. prototype 지정 Renderer Process에서 플러그인 src/renderer/plugins/ipc.js 내에 prototype지정. 사용 vue나 store에서 사용. 파일 쓰기 this.$writeFile(‘파일경로’, ‘데이타’, [‘옵션’]) 각 파라미터는 fs.writeFile와 동일 Promise로 리턴되므로 async await를 사용 파일 읽기 this.$readFile(‘파일경로’, [‘옵션’]) 각 파라미터는 fs.readFile와 동일 Promise로 리턴되므로 async await를 사용 Related Posts","categories":[],"tags":[]},{"title":"국가별 정보시각화 레펀러스 사이트","slug":"cyber-attack-map-ref","date":"2019-08-26T05:21:07.000Z","updated":"2019-08-28T04:33:03.760Z","comments":true,"path":"2019/08/26/cyber-attack-map-ref/","link":"","permalink":"https://haeju.github.io/2019/08/26/cyber-attack-map-ref/","excerpt":"","text":"업체별 지도 데이타 시각화 내용을 소개합니다. 1. 노스(Norse) 실시간으로 해킹 상황을 볼수 있으며 게임을 보는 듯한 현란한 모션 이펙트 화면을 제공 공격 effect 여겨 볼만함 Attak Orgin ( 공격 국가 ) , attack Target ( 공격 대상 ), Attaks ( 공격 실시간 로그 ), Attak Types ( 공격 종류 ) http://map.norsecorp.com ( 현재 사이트 닫힘 ) https://www.youtube.com/watch?v=xq3CKDY-HsA 2. 카스퍼스키(Kaspersky) 다양한 진단도구(On-Access Scan, On-demand Scan) 웹 백신·메일 백신(Web and Mail Anti-Viruses) 취약점 분석(Vulnerability Scan) 침입탐지 시스템(Intrusion Detection System) 등 위협의 다채로운 분석 공격 지점을 찍으면 1인칭 시점으로 줌인되어 공격 경로 확인가능 3D Globe 및 2D Map 변환 기능 제공 Trial 설치 파일 다운로드 가능 https://cybermap.kaspersky.com/ https://www.youtube.com/watch?v=vuOLiu3wFQ0 3. 체크포인트 소프트웨어 (Check Point ) 비교적 단순한 화면과 인터렉티브 공격대상 국가 TOP 순위정보와 하단에 실시간으로 타입별, 공격 국가,공격 대상 국가 정보 제공 https://threatmap.checkpoint.com/ThreatPortal/livemap.html 4. 포티넷 (Fortinet) 공격 에니메이션 Effect 지도에서 국가 선택시 화면 확대, 공격 현황 제공 매 초마다 발생하는 위협의 0.01%만을 지도에 표시한다. 이러한 데이터는 어떠한 웹 필터링이나 응용프로그램 제어 없이 포티게이트의 IPS 데이터만을 이용 https://threatmap.fortiguard.com/ 5. 파이어아이 (FireEye) 지난 30일 동안 파이어아이의 양방향 공유 고객으로부터 수집된 실제 데이터 샘플 지도에 표시된 데이터는 ‘명령 및 제어(C&amp;C) 서버’로의 멀웨어 통신이다. ‘Attacker’는 C&amp;C서버를 나타낸다. 그리고 ‘Target’은 고객을 나타낸다. https://www.fireeye.com/cyber-map/threat-map.html 6. 아버 네트웍스 구글 아이디어즈(Google Ideas)와 함께 만든 하이브리드 지도 로우 데이터는 300개 이상의 ISP 고객과 130Tbps의 전세계 트래픽을 기반 http://www.digitalattackmap.com/ Related Posts","categories":[],"tags":[]},{"title":"마크 다운 예제","slug":"mark-down-sample","date":"2019-08-23T11:18:48.000Z","updated":"2019-08-26T02:12:46.288Z","comments":true,"path":"2019/08/23/mark-down-sample/","link":"","permalink":"https://haeju.github.io/2019/08/23/mark-down-sample/","excerpt":"","text":"d3SVG 구성요소 &lt;svg&gt; &lt;circle&gt;, &lt;rect&gt;, &lt;line&gt;, &lt;polygon&gt; &lt;text&gt; &lt;g&gt; &lt;path&gt; column column column a b c Lorem ipsum dolor sit amet, consectetur adipisicing elit Lorem ipsum dolor sit amet, consectetur adipisicing elit checkBox 1234567created () &#123; // 브라우저의 Resize 이벤트를 컴포넌트의 인스턴스 메서드에 연결합니다. this._onResizeWorldMap = _.throttle(this.onResizeWorldMap, 500) // 리사이즈 이벤트 연결 window.addEventListener('resize', this._onResizeWorldMap) &#125; 그냥 태그를 쓰면 사라지니까 한줄 코드를 써야&lt;a&gt; 합니다.짧은 코드를 쓸 때 유용합니다 해시코드 사이트 탕탕 빵야 타당타당 빠밤빠밤 하나 둘 셋 셋에 하나 셋에 둘 교수님이 말씀하시길코딩하기 좋은 날이구나","categories":[],"tags":[]},{"title":"d3","slug":"d3-introduce","date":"2019-08-23T11:17:29.000Z","updated":"2019-08-28T01:54:32.907Z","comments":true,"path":"2019/08/23/d3-introduce/","link":"","permalink":"https://haeju.github.io/2019/08/23/d3-introduce/","excerpt":"","text":"d3 SVG 구성요소 &lt;svg&gt; &lt;circle&gt;, &lt;rect&gt;, &lt;line&gt;, &lt;polygon&gt; &lt;text&gt; &lt;g&gt; &lt;path&gt; d 속성이 결정하는 도형의 영역이다. d 속성 마지막에 Z 문자열이 있으면 영역(area)이되고 없다면 선이나 곡선등 열린 도형(?)이 된다. 데이타 변환 캐스팅 ( 형변환 ) 정규화 ( 스케일과 규모변경 ) scaleLinear() 비닝 ( 그룹화 : 데이터 분류 ) 내포 ( 계층화 ) d3가 제공하는 기능의 3대 유형 생성기 &lt;path&gt;요소의 d 속성을 작성하는데 필요한 과정 추상화함으로써 복잡한 SVG &lt;path&gt;요소의 생성과정을 단순하게 만들어준다. &lt;path&gt;요소에 들어가는 d 속성 문자열을 생성 d3.svg.line(), d3.svg.area(), d3.svg.arc(), d3.svg.diagoal() 컴포넌트 특정 차트 컴포넌트를 그리는데 필요한 일련의 화면 객체 생성 d3.svg.axis : &lt;line&gt;, &lt;path&gt;, &lt;g&gt;, &lt;text&gt;요소를 생성 12345678910111213141516171819202122232425262728293031323334import * as d3 from 'd3'var scatterData = [&#123; friends: 5, salary: 22000 &#125;,&#123; friends: 3, salary: 18000 &#125;, &#123; friends: 10, salary: 88000 &#125;,&#123; friends: 0, salary: 180000 &#125;, &#123; friends: 27, salary: 56000 &#125;,&#123; friends: 8, salary: 74000 &#125;]function test(instance) &#123; const targetContainer = instance.$el d3.select(targetContainer).append('svg') draw() &#125;function draw()&#123; var xExtent = d3.extent(scatterData, d=&gt; d.salary) var yExtent = d3.extent(scatterData, d=&gt; d.friends) var xScale = d3.scaleLinear().domain(xExtent).range([0,500]) var yScale = d3.scaleLinear().domain(yExtent).range([0,500]) d3.select('svg').selectAll('circle') .data(scatterData).enter().append('circle') .attr('r', 5).attr('cx', d =&gt; xScale(d.salary)) .attr('cy', d =&gt; yScale(d.friends)) var yAxis = d3.axisRight().scale(yScale) d3.select('svg').append('g').attr('id','yAxisG').call(yAxis) var xAxis = d3.axisBottom().scale(xScale) d3.select('svg').append('g').attr('id','xAxisG').call(xAxis)&#125;export &#123; test&#125; 점으로 선 그리기 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import * as d3 from 'd3'var scatterData = [&#123; day: 1, friends: 5, salary: 3 &#125;,&#123; day: 2, friends: 3, salary: 4 &#125;, &#123; day: 3, friends: 10, salary: 7 &#125;,&#123; day: 4, friends: 0, salary: 7 &#125;, &#123; day: 5, friends: 27, salary: 11 &#125;,&#123; day: 6, friends: 8, salary: 1 &#125;]function test(instance) &#123; const targetContainer = instance.$el d3.select(targetContainer).append('svg') draw()&#125;function draw() &#123; const blue = '#5eaec5', green = '#92c463' var xScale = d3.scaleLinear().domain([0, 10]).range([0, 500]) var yScale = d3.scaleLinear().domain([0, 27]).range([0, 500]) var xAxis = d3.axisBottom() .scale(xScale) .tickSize(500) .ticks(4) d3.select('svg').append('g').attr('id', 'xAxisG').call(xAxis) var yAxis = d3.axisRight() .scale(yScale) .ticks(16) .tickSize(500) d3.select('svg').append('g').attr('id', 'yAxisG').call(yAxis) d3.select('svg').selectAll('circle.friends') .data(scatterData) .enter() .append('circle') .attr('class', 'friends') .attr('r', 5) .attr('cx', d =&gt; xScale(d.day)) .attr('cy', d =&gt; yScale(d.friends)) .style('fill', blue) d3.select('svg').selectAll('circle.salary') .data(scatterData) .enter() .append('circle') .attr('class', 'salary') .attr('r', 5) .attr('cx', d =&gt; xScale(d.day)) .attr('cy', d =&gt; yScale(d.salary)) .style('fill', green) // SVG 그림 코드 반환 var tweetLineFriends = d3.line() .x(d =&gt; xScale(d.day)) .y(d =&gt; yScale(d.friends)) //선 보간법 설정 tweetLineFriends.curve(d3.curveCardinal) d3.select('svg') .append('path') .attr('d', tweetLineFriends(scatterData)) .attr('fill', 'none') .attr('stroke', 'darkred') .attr('stroke-width', 2) // SVG 그림 코드 반환 var tweetLineSalary = d3.line() .x(d =&gt; xScale(d.day)) .y(d =&gt; yScale(d.salary)) //선 보간법 설정 tweetLineSalary.curve(d3.curveStep) // tweetLineSalary.curve(d3.curveBasis) d3.select('svg') .append('path') .attr('d', tweetLineSalary(scatterData)) .attr('fill', 'none') .attr('stroke', 'gray') .attr('stroke-width', 2) &#125; 누적 차트 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import * as d3 from 'd3'function test(instance) &#123; const targetContainer = instance.$el d3.select(targetContainer).append('svg') draw()&#125;// movie.csv// day,titanic,avatar,akira,frozen,deliverance,avengers// 1,20,8,3,0,0,0// 2,18,5,1,13,0,0// 3,14,3,1,10,0,0// 4,7,3,0,5,27,15// 5,4,3,0,2,20,14// 6,3,1,0,0,10,13// 7,2,0,0,0,8,12// 8,0,0,0,0,6,11// 9,0,0,0,0,3,9// 10,0,0,0,0,1,8function draw() &#123; d3.csv('/src/renderer/pages/countryInfo/d3Sample/4/movie.csv').then(data =&gt; areaChart(data))&#125;function areaChart(data) &#123; var fillScale = d3.scaleOrdinal() .domain(['titanic', 'avatar', 'akira', 'frozen', 'deliverance', 'avengers']) .range(['#fcd88a', '#cf7c1c', '#93c464', '#75734F', '#5eafc6', '#41a368']) var xScale = d3.scaleLinear().domain([1, 8]).range([20, 470]) var yScale = d3.scaleLinear().domain([0, 55]).range([480, 20]) Object.keys(data[0]).forEach(key =&gt; &#123; if (key != 'day') &#123; var movieArea = d3.area() .x(d =&gt; xScale(d.day)) .y0(d =&gt; yScale(simpleStacking(d, key) - d[key])) .y1(d =&gt; yScale(simpleStacking(d, key))) .curve(d3.curveBasis) d3.select('svg') .append('path') .style('id', key + 'Area') .attr('d', movieArea(data)) .attr('fill', fillScale(key)) .attr('stroke', 'black') .attr('stroke-width', 1) &#125; &#125;) function simpleStacking(lineData, lineKey) &#123; var newHeight = 0 Object.keys(lineData).every(key =&gt; &#123; if (key !== 'day') &#123; newHeight += parseInt(lineData[key]) if (key === lineKey) &#123; return false &#125; &#125; return true &#125;) return newHeight &#125; var legendA = d3.legendColor().scale(fillScale) d3.select('svg') .style('width', '1000px') d3.select('svg') .append('g') .attr('transform', 'translate(500, 0)') .call(legendA)&#125; d3.svg.brush 레이아웃 일련의 데이터, 그리고 생성기로 구성된 배열을 입력받아 특정 위치와 크기로 그리는데 필요한 데이터 속성을 동적,정적 추가","categories":[],"tags":[{"name":"d3, svg","slug":"d3-svg","permalink":"https://haeju.github.io/tags/d3-svg/"}]}]}